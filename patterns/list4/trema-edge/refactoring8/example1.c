static hf_register_info hf[] = {
    { &hf_dump_header,
      { "Dump header", "trema.dump_header",
        FT_NONE, BASE_NONE, NO_STRINGS, NO_MASK, "Dump header", HFILL }},
    { &hf_dump_type,
      { "Type", "trema.dump_type",
        FT_UINT16, BASE_DEC, VALS( names_dump_type ), NO_MASK, "Type", HFILL }},
    { &hf_dump_event_time,
      { "Event occurred at", "trema.dump_event_time",
        FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NO_STRINGS, NO_MASK, "Event Occurred at", HFILL }},
    { &hf_dump_app_name_length,
      { "Application name length", "trema.dump_app_name_length",
        FT_UINT16, BASE_DEC, NO_STRINGS, NO_MASK, "Application name length", HFILL }},
    { &hf_dump_service_name_length,
      { "Service name length", "trema.dump_service_name_length",
        FT_UINT16, BASE_DEC, NO_STRINGS, NO_MASK, "Service name length", HFILL }},
    { &hf_dump_data_length,
      { "Data length", "trema.dump_data_length",
        FT_UINT32, BASE_DEC, NO_STRINGS, NO_MASK, "Data length", HFILL }},
    { &hf_dump_app_name,
      { "Application name", "trema.dump_app_name",
        FT_STRING, BASE_NONE, NO_STRINGS, NO_MASK, "Application name", HFILL }},
    { &hf_dump_service_name,
      { "Service name", "trema.dump_service_name",
        FT_STRING, BASE_NONE, NO_STRINGS, NO_MASK, "Service name", HFILL }},
    { &hf_message_header,
      { "Message header", "trema.message_header",
        FT_NONE, BASE_NONE, NO_STRINGS, NO_MASK, "Mesasge header", HFILL }},
    { &hf_version,
      { "Version", "trema.version",
        FT_UINT8, BASE_DEC, NO_STRINGS, NO_MASK, "Version", HFILL }},
    { &hf_message_type,
      { "Type", "trema.type",
        FT_UINT8, BASE_DEC, VALS( names_message_type ), NO_MASK, "Type", HFILL }},
    { &hf_tag,
      { "Tag", "trema.tag",
        FT_UINT16, BASE_DEC, VALS( names_service_tag ), NO_MASK, "Tag", HFILL }},
    { &hf_message_length,
      { "Length", "trema.length",
        FT_UINT32, BASE_DEC, NO_STRINGS, NO_MASK, "Length", HFILL }},
    { &hf_service_header,
      { "OpenFlow service header", "trema.service_header",
        FT_NONE, BASE_NONE, NO_STRINGS, NO_MASK, "OpenFlow service header", HFILL }},
    { &hf_datapath_id,
      { "Datapath ID", "trema.datapath_id",
        FT_UINT64, BASE_HEX, NO_STRINGS, NO_MASK, "Datapath ID", HFILL }},
    { &hf_service_name_length,
      { "Service name length", "trema.service_name_length",
        FT_UINT16, BASE_DEC, NO_STRINGS, NO_MASK, "Service name length", HFILL }},
    { &hf_service_name,
      { "Service name", "trema.service_name",
        FT_STRING, BASE_NONE, NO_STRINGS, NO_MASK, "Service name", HFILL }},
    { &hf_context_handle,
      { "Request/Reply context handle", "trema.context_handle",
        FT_NONE, BASE_NONE, NO_STRINGS, NO_MASK, "Request/Reply context handle", HFILL }},
    { &hf_transaction_id,
      { "Transaction ID", "trema.transaction_id",
        FT_UINT32, BASE_DEC, NO_STRINGS, NO_MASK, "Transaction ID", HFILL }},
    { &hf_hex_dump,
      { "[Unknown data]", "trema.hex_dump",
        FT_NONE, BASE_NONE, NO_STRINGS, NO_MASK, "Hex dump", HFILL }},

    // pcap_dump_header
    { &hf_pcap_dump_header,
      { "PCAP dump header", "trema.pcap_dump_header",
        FT_NONE, BASE_NONE, NO_STRINGS, NO_MASK, "PCAP dump header", HFILL }},
    { &hf_pcap_dump_datalink,
      { "Datalink", "trema.pcap_dump_datalink",
        FT_UINT32, BASE_DEC, VALS( names_datalink_type ), NO_MASK, "Datalink", HFILL }},
    { &hf_pcap_dump_interface,
      { "Interface", "trema.pcap_dump_interface",
        FT_STRING, BASE_NONE, NO_STRINGS, NO_MASK, "Inerface", HFILL }},

    // pcap_pkthdr
    { &hf_pcap_pkthdr,
      { "PCAP packet header", "trema.pcap_pkthdr",
        FT_NONE, BASE_NONE, NO_STRINGS, NO_MASK, "PCAP packet header", HFILL }},
    { &hf_pcap_pkthdr_ts,
      { "Captured at", "trema.pcap_pkthdr_ts",
        FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NO_STRINGS, NO_MASK, "Captured at", HFILL }},
    { &hf_pcap_pkthdr_caplen,
      { "Capture length", "trema.pcap_pkthdr_caplen",
        FT_UINT32, BASE_DEC, NO_STRINGS, NO_MASK, "Capture length", HFILL }},
    { &hf_pcap_pkthdr_len,
      { "Frame length", "trema.pcap_pkthdr_len",
        FT_UINT32, BASE_DEC, NO_STRINGS, NO_MASK, "Frame length", HFILL }},

    // syslog_dump_header
    { &hf_syslog_dump_header,
      { "Syslog dump header", "trema.syslog_dump_header",
        FT_NONE, BASE_NONE, NO_STRINGS, NO_MASK, "Syslog dump header", HFILL }},
    { &hf_syslog_dump_receive_time,
      { "Received at", "trema.syslog_dump_receive_time",
        FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NO_STRINGS, NO_MASK, "Received at", HFILL }},

    // text_dump_header
    { &hf_text_dump_header,
      { "Text dump header", "trema.text_dump_header",
        FT_NONE, BASE_NONE, NO_STRINGS, NO_MASK, "Text dump header", HFILL }},
    { &hf_text_dump_receive_time,
      { "Received at", "trema.text_dump_receive_time",
        FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NO_STRINGS, NO_MASK, "Received at", HFILL }},
    { &hf_text_dump_string,
      { "Text string", "trema.text_dump_string",
        FT_STRING, BASE_NONE, NO_STRINGS, NO_MASK, "Text string", HFILL }},

    // raw syslog message
    { &hf_syslog_dump_message,
      { "Raw syslog message", "trema.syslog_message",
        FT_STRING, BASE_NONE, NO_STRINGS, NO_MASK, "Raw syslog message", HFILL }},

    // Fragment fields
    { &hf_trema_fragments,
      { "Trema fragments", "trema.fragments",
        FT_NONE, BASE_NONE, NO_STRINGS, NO_MASK, NULL, HFILL }},
    { &hf_trema_fragment,
      { "Trema fragment", "trema.fragment",
        FT_FRAMENUM, BASE_NONE, NO_STRINGS, NO_MASK, NULL, HFILL }},
    { &hf_trema_fragment_overlap,
      { "Trema fragment overlap", "trema.fragment.overlap",
        FT_BOOLEAN, 0, NO_STRINGS, NO_MASK, NULL, HFILL }},
    { &hf_trema_fragment_overlap_conflict,
      { "Trema fragment overlapping with conflicting data", "trema.fragment.overlap.conflicts",
        FT_BOOLEAN, 0, NO_STRINGS, NO_MASK, NULL, HFILL }},
    { &hf_trema_fragment_multiple_tails,
      { "Trema has multiple tail fragments", "trema.fragment.multiple_tails",
        FT_BOOLEAN, 0, NO_STRINGS, NO_MASK, NULL, HFILL }},
    { &hf_trema_fragment_too_long_fragment,
      { "Trema fragment too long", "trema.fragment.too_long_fragment",
        FT_BOOLEAN, 0, NO_STRINGS, NO_MASK, NULL, HFILL }},
    { &hf_trema_fragment_error,
      { "Trema defragmentation error", "trema.fragment.error",
        FT_FRAMENUM, BASE_NONE, NO_STRINGS, NO_MASK, NULL, HFILL }},
#ifndef WIRESHARK_VERSION_OLDER_THAN_160
    { &hf_trema_fragment_count,
      { "Trema defragmentation count", "trema.fragment.count",
        FT_UINT32, BASE_DEC, NO_STRINGS, NO_MASK, NULL, HFILL }},
#endif
    { &hf_trema_reassembled_in,
      { "Reassembled in", "trema.reassembled.in",
        FT_FRAMENUM, BASE_NONE, NO_STRINGS, NO_MASK, NULL, HFILL }},
    { &hf_trema_reassembled_length,
      { "Reassembled length", "trema.reassembled.length",
        FT_UINT32, BASE_DEC, NO_STRINGS, NO_MASK, NULL, HFILL }},
  };
